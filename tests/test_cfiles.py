#!/usr/bin/env python
"""
Test all the .c files in the cfiles dir

Generating gold file with clang
===============================

Note that a gold file can be generated by just running the test before any
changes are done, clang is only necessary to simplify verifying the IR is
correct when the test is first written.

llvmlite 0.31.0 uses clang 8.0.0

  >>> llvmlite._version.version_version 

    '0.31.0'

  >>> llvmlite.binding.llvm_version_info 

    (8L, 0L, 0L)

The closests available llvm seems to be 8.0.1 which can be downloaded from
https://releases.llvm.org/download.html#8.0.1

    clang.exe --version
    clang version 8.0.1 (tags/RELEASE_801/final)
    Target: x86_64-pc-windows-msvc
    Thread model: posix
    InstalledDir: ...

Other versions of clang are known to produce different enough code, specifically
Android NDK versions 

    C:\android-ndk-r15c\toolchains\llvm\prebuilt\windows-x86_64\bin\clang.exe --version
    Android clang version 5.0.300080  (based on LLVM 5.0.300080)
    Target: x86_64-unknown-linux
    Thread model: posix
    InstalledDir: ...

produce LP64 code (longs are 64-bit) which is different from LLP64 used on
Windows (longs are 32-bit, long longs are 64-bit)


Known codegen differences between clang and epycc
-------------------------------------------------

Due to the way epycc generates code by calling snippets, the resulting optimized
code can be equivalent but line to line different between clang compiling the
same piece of C code.


Parameter order
~~~~~~~~~~~~~~~

Most of the mismatches are in the _Bool result type when the same type is used for
both parameters, which causes one parameter or the other to be picked first
differently between epycc and clang:

'%3 = zext i1 %0 to i32' vs '%3 = zext i1 %1 to i32'

clang

    define dso_local zeroext i1 @test_add___Bool___Bool___Bool(i1 zeroext, i1 zeroext) local_unnamed_addr #0 {
        %3 = zext i1 %0 to i32
        %4 = sext i1 %1 to i32
        %5 = icmp ne i32 %3, %4
        ret i1 %5
    }

epycc

    define dso_local zeroext i1 @test_add___Bool___Bool___Bool(i1 zeroext, i1 zeroext) local_unnamed_addr #0 {
        %3 = zext i1 %1 to i32
        %4 = sext i1 %0 to i32
        %5 = icmp ne i32 %3, %4
        ret i1 %5
    }

'%3 = sub i32 0, %1' vs '%3 = sub i32 0, %0'

clang

    define dso_local zeroext i1 @test_add___Bool__int__int(i32, i32) local_unnamed_addr #0 {
        %3 = sub i32 0, %1
        %4 = icmp ne i32 %3, %0
        ret i1 %4
    }

epycc

    define dso_local zeroext i1 @test_add___Bool__int__int(i32, i32) local_unnamed_addr #0 {
        %3 = sub i32 0, %0
        %4 = icmp ne i32 %3, %1
        ret i1 %4
    }


'%6 = add i32 %5, %4' vs '%6 = add i32 %4, %5'

clang

    define dso_local float @bitwise_ops(i32, i32) local_unnamed_addr #0 {
        %3 = and i32 %0, 65535
        %4 = or i32 %1, 255
        %5 = xor i32 %3, 1
        %6 = add i32 %5, %4
        %7 = uitofp i32 %6 to float
        ret float %7
    }

epycc

    define dso_local float @bitwise_ops(i32, i32) local_unnamed_addr #0 {
        %3 = and i32 %0, 65535
        %4 = or i32 %1, 255
        %5 = xor i32 %3, 1
        %6 = add i32 %4, %5
        %7 = uitofp i32 %6 to float
        ret float %7
    }


Different operations
~~~~~~~~~~~~~~~~~~~~

Looks like the codegen can be different but equivalent (this happens on goldbot
using clang trunk, so it's not an llvmlite vs. clang issue).

'%4 = sext i1 %1 to i32' vs '%4 = zext i1 %1 to i32'

gold

    define dso_local zeroext i1 @test_add___Bool__char___Bool(i8, i1 zeroext) local_unnamed_addr #0 {
        %3 = sext i8 %0 to i32
        %4 = sext i1 %1 to i32
        %5 = icmp ne i32 %3, %4
        ret i1 %5
    }

epycc

    define dso_local zeroext i1 @test_add___Bool__char___Bool(i8 signext, i1 zeroext) local_unnamed_addr #0 {
        %3 = sext i8 %0 to i32
        %4 = zext i1 %1 to i32
        %5 = sub nsw i32 0, %3
        %6 = icmp ne i32 %4, %5
        ret i1 %6
    }

The unoptimized code is essentially the same for clang and epycc:

clang

    ; Function Attrs: noinline nounwind optnone uwtable
    define dso_local zeroext i1 @test_add___Bool__char___Bool(i8, i1 zeroext) #0 {
        %3 = alloca i8, align 1
        %4 = alloca i8, align 1
        %5 = zext i1 %1 to i8
        store i8 %5, i8* %3, align 1
        store i8 %0, i8* %4, align 1
        %6 = load i8, i8* %4, align 1
        %7 = sext i8 %6 to i32
        %8 = load i8, i8* %3, align 1
        %9 = trunc i8 %8 to i1
        %10 = zext i1 %9 to i32
        %11 = add nsw i32 %7, %10
        %12 = icmp ne i32 %11, 0
        ret i1 %12
    }

epycc

    define dso_local zeroext i1 @test_add___Bool__char___Bool(i8, i1 zeroext) {
        %3 = call i32 @cnv__int__char(i8 %0)
        %4 = call i32 @cnv__int___Bool(i1 %1)
        %5 = call i32 @add__int__int__int(i32 %3, i32 %4)
        %6 = call i1 @cnv___Bool__int(i32 %5)
        ret i1 %6
    }

    define dso_local i32 @cnv__int__char(i8) {
        %2 = alloca i8, align 1
        store i8 %0, i8* %2, align 1
        %3 = load i8, i8* %2, align 1
        %4 = sext i8 %3 to i32
        ret i32 %4
    }

    define dso_local i32 @cnv__int___Bool(i1 zeroext) {
        %2 = alloca i8, align 1
        %3 = zext i1 %0 to i8
        store i8 %3, i8* %2, align 1
        %4 = load i8, i8* %2, align 1
        %5 = trunc i8 %4 to i1
        %6 = zext i1 %5 to i32
        ret i32 %6
    }

    define dso_local i32 @add__int__int__int(i32, i32) {
        %3 = alloca i32, align 4
        %4 = alloca i32, align 4
        store i32 %1, i32* %3, align 4
        store i32 %0, i32* %4, align 4
        %5 = load i32, i32* %4, align 4
        %6 = load i32, i32* %3, align 4
        %7 = add nsw i32 %5, %6
        ret i32 %7
    }

    define dso_local zeroext i1 @cnv___Bool__int(i32) {
        %2 = alloca i32, align 4
        store i32 %0, i32* %2, align 4
        %3 = load i32, i32* %2, align 4
        %4 = icmp ne i32 %3, 0
        ret i1 %4
    }


"""
import os
import re
import string
import sys
import time

# Add the parent dir to syspath to be able to import epycc
epycc_dirpath = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(epycc_dirpath)
import epycc

def test_single_cfile(test_filepath, ignore_existing_files=False):
    print "testing", os.path.split(test_filepath)[1]

    out_dir = os.path.join(epycc_dirpath, "_out")
    gold_dir = os.path.join(epycc_dirpath, "_out")

    _, test_filename = os.path.split(test_filepath)
    test_ir_filepath = os.path.join(out_dir, test_filename + ".ll")
    test_optimized_ir_filepath = os.path.join(out_dir, test_filename + ".optimized.ll")

    gold_filename = "gold_" + test_filename
    gold_ir_filepath = os.path.join(gold_dir, gold_filename + ".ll")
    gold_optimized_ir_filepath = os.path.join(gold_dir, gold_filename + ".optimized.ll")

    #  If the gold IR file already exists, no need to generate it from clang
    if (ignore_existing_files or (not os.path.exists(gold_optimized_ir_filepath)) or 
        (os.path.getmtime(test_filepath) >= os.path.getmtime(gold_optimized_ir_filepath))):
        # Golden file can be obtained by:
        # - compiling with clang
        # - running epycc before the change and copying from out to golden (this assumes
        #   a fresh repo passes the tests)
        epycc.invoke_clang(test_filepath, gold_ir_filepath)
        epycc.invoke_clang(test_filepath, gold_optimized_ir_filepath, "-O2")
        

    # Compile with epycc

    # Invoke epycc in file chunks, otherwise the Lark Early parser errors with stack
    # overflow with a file with thousands of lines (it's also possible that it 
    # reduces the parsing time, but seems to be in the noise, parsing hovers around
    # 13 lines/sec)
    # XXX This can also be used to multiprocess the test
    i = 1
    lines_per_compile = 1000
    s = ""
    with open(test_filepath, "r") as f, open(test_ir_filepath, "w") as f2, open(test_optimized_ir_filepath, "w") as f3:
        
        start_time = time.time()
        l = None
        while (l != ""):
            l = f.readline()
            if ((i % lines_per_compile == 0) or ((l == "") and (s != ""))):
                # XXX For hand-gilded tests we don't need optimized versions and we
                #     could just generate IR without compiling?
                lib = epycc.epycc_compile(s)
                f2.write(lib.ir)
                f3.write(lib.ir_optimized)
                print i, i * 1.0 / (time.time() - start_time), "lines/sec"
                s = ""
            s += l
            i += 1
            
    epycc_ir = epycc.load_functions_ir(test_optimized_ir_filepath)
    gold_ir = epycc.load_functions_ir(gold_optimized_ir_filepath)

    # Analyze line by line for mismatches between gold and test IR files
    unexpected_mismatch_count = 0
    test_count = 0
    # Start with the gold IR since if the gold IR was generated with clang, it will
    # not contain all the helper functions the test IR does contain (and which don't
    # need testing)
    for fn_name in gold_ir:
        # XXX Ignore the first line for now because clang contains "#0" but llvmlite
        #     doesn't
        ## print "Checking", fn_name
        test_count += 1
        function_mismatch_count = 0
        mismatches = []
        for l_epycc, l_gold in zip(epycc_ir[fn_name][1:], gold_ir[fn_name][1:]):
            if (l_gold != l_epycc):
                function_mismatch_count += 1
                mismatches.append([l_gold, l_epycc])
        
        # Get expected mismatch count from function name
        # XXX Use epycc parsing and get this from pragmas or such?
        m = re.match(r".*__mm(\d+)", fn_name)
        expected_function_mismatch_count = 0
        if (m is not None):
            expected_function_mismatch_count = int(m.group(1))

        if (expected_function_mismatch_count != function_mismatch_count):
            print "Expected",expected_function_mismatch_count, "mismatches but found", function_mismatch_count, "in", fn_name,":"
            for mismatch in mismatches:
                l_gold, l_epycc = mismatch
                print repr(l_gold), "vs",  repr(l_epycc)
            print "gold"
            print string.join(gold_ir[fn_name], "\n")
            print "epycc"
            print string.join(epycc_ir[fn_name], "\n")

        unexpected_mismatch_count += (function_mismatch_count - expected_function_mismatch_count)

    print "Ran", test_count, "tests, found", unexpected_mismatch_count, "unexpected mismatches"

    return unexpected_mismatch_count


if (__name__ == "__main__"):
    ignore_existing_files = False

    cfiles_dirpath = os.path.join(os.path.dirname(os.path.abspath(__file__)), "cfiles")
    for (dirpath, dirnames, filenames) in os.walk(cfiles_dirpath):
        for test_filename in filenames:
            if (test_filename.endswith(".c")):
                test_filepath = os.path.join(dirpath, test_filename)

                unexpected_mismatch_count = test_single_cfile(test_filepath, ignore_existing_files)
                assert(unexpected_mismatch_count == 0)